module snabb-router-v1 {
  namespace snabb:router;
  prefix router;

  import ietf-inet-types { prefix inet; }
  import ietf-yang-types { prefix yang; }

  organization "Squiz UK Ltd";
  contact "Ben Agricola <bagricola@squiz.co.uk>";
  description
   "Configuration for the Snabb Switch Router";

  revision 2017-08-12 {
    description
     "Initial revision.";
  }

  container router-config {
    description
     "Configuration for Snabb router.";

    grouping traffic-filters {
      description
       "Ingress and egress filters describing the set of packets
        that should be allowed to pass, as pflang filters.  pflang
        is the language of tcpdump, libpcap and other tools.  Note
        that if VLAN tagging is enabled, the filters run on packets
        after VLAN tags have been stripped off.";
      leaf ingress-filter {
        type string;
        description
         "Filter for incoming traffic.  Packets that do not match
          the filter will be silently dropped.";
      }
      leaf egress-filter {
        type string;
        description
         "Filter for outgoing traffic.  Packets that do not match
          the filter will be silently dropped.";
      }
    }

    grouping icmp-policy {
      description
       "The Router can be configured to allow or drop incoming ICMP
        messages, and to generate outgoing ICMP error messages or
        not.";

      leaf allow-incoming-icmp {
        type boolean;
        default true;
        description
         "Whether to allow incoming ICMP packets.";
      }

      leaf generate-icmp-errors {
        type boolean;
        default true;
        description
         "Whether to generate outgoing ICMP error messages.";
      }
    }

    grouping vlan-tagging {
      description
       "802.1Q Ethernet tagging.";

      leaf-list vlan-tag {
        type uint16 {
          range 0..4095;
        }
        description
         "802.1Q Ethernet VLAN tag for this interface.";
      }
    }

    grouping error-rate-limiting {
      description
       "These settings limit the rate of ICMP error message
        transmission.";

      container error-rate-limiting {
        leaf packets {
          type uint32;
          description
           "The number of ICMP error messages which can be sent within
            the specified time period.";
        }

        leaf period {
          type uint32 { range 1..max; }
          default 2;
          description
           "The time period given in seconds.";
        }
      }
    }

    grouping reassembly {
      description
       "These settings limit the resources devoted to reassembling
        fragmented packets.";

      container reassembly {
        leaf max-fragments-per-packet {
          type uint32 { range 1..max; }
          default 20;
          description
           "The maximum number of fragments per reassembled packet.
            Attempts to reassemble a packet using more fragments than
            this threshold will fail and the reassembly data will be
            discarded.";
        }

        leaf max-packets {
          type uint32;
          default 20000;
          description
           "The maximum number of concurrent reassembly attempts.  If
            this limit is reached, an additional reassembly will cause
            random eviction of an ongoing reassembly. Note that this
            setting directly affects memory usage; the memory buffer
            allocated to reassembly is this maximum number of
            reassemblies times 25 kilobytes each.";
        }
      }
    }

    leaf name {
      type string;
      description
        "Name of Router instance. This must be unique amongst the Snabb
         processes on the system. This may be specified either here, in the
         YANG configuration or via the command line when the Router is started.

         The order of presidence for this leaf is as followers:
         1. The name set on an already running Router instance via snabb set.
         2. A command line option to specify the name upon starting the Router
            instance (i.e. overriding this value).
         3. The value here in the configuration when starting a router instance.

         If no name is specified the router can be referred to using the PID of
         the Router process on the system.";
    }

    leaf socket {
      type string;
      mandatory true;
      description
       "zAPI Socket to listen on";
    }

    list interface {
      key device;

      description
       "Configuration for router connected interface.";

      leaf type {
          type enumeration {
              enum routed;
              enum mgmt;
          }
          description
           "Interface type. This can be 'routed' or 'mgmt'";
          default routed;
      }

      leaf device {
        type string;
        mandatory true;
        description
         "Device name or PCI address";
      }


      leaf-list ip {
        type inet:ipv4-address;
        mandatory true;
        description
         "A list of IP addresses assigned to the network interface.  Used
          when generating error messages and responding to ICMP echo
          requests.";
      }

      leaf mtu {
        type uint16;
        default 1500;
        description
         "Maximum packet size to send on the IPv4 interface.";
      }

      uses traffic-filters;
      uses icmp-policy;
      uses vlan-tagging;
      uses error-rate-limiting;
      uses reassembly;
    }
  }

  container router-state {
    description "State data about router.";
    config false;

    leaf drop-all-ipv4-iface-bytes {
      type yang:zero-based-counter64;
      description
        "All dropped packets and bytes that came in over IPv4 interfaces,
         whether or not they actually IPv4 (they only include data about
         packets that go in/out over the wires, excluding internally generated
         ICMP packets).";
    }
    leaf drop-all-ipv4-iface-packets {
      type yang:zero-based-counter64;
      description
        "All dropped packets and bytes that came in over IPv4 interfaces,
         whether or not they actually IPv4 (they only include data about
         packets that go in/out over the wires, excluding internally generated
         ICMP packets).";
    }
    leaf drop-all-ipv6-iface-bytes {
      type yang:zero-based-counter64;
      description
        "All dropped packets and bytes that came in over IPv6 interfaces,
         whether or not they actually IPv6 (they only include data about packets
         that go in/out over the wires, excluding internally generated ICMP
         packets).";
    }
    leaf drop-all-ipv6-iface-packets {
      type yang:zero-based-counter64;
      description
        "All dropped packets and bytes that came in over IPv6 interfaces,
         whether or not they actually IPv6 (they only include data about packets
         that go in/out over the wires, excluding internally generated ICMP
         packets).";
    }
    leaf drop-bad-checksum-icmpv4-bytes {
      type yang:zero-based-counter64;
      description "ICMPv4 packets dropped because of a bad checksum.";
    }
    leaf drop-bad-checksum-icmpv4-packets {
      type yang:zero-based-counter64;
      description "ICMPv4 packets dropped because of a bad checksum.";
    }
    leaf drop-in-by-policy-icmpv4-bytes {
      type yang:zero-based-counter64;
      description "Incoming ICMPv4 packets dropped because of current policy.";
    }
    leaf drop-in-by-policy-icmpv4-packets {
      type yang:zero-based-counter64;
      description "Incoming ICMPv4 packets dropped because of current policy.";
    }
    leaf drop-in-by-policy-icmpv6-bytes {
      type yang:zero-based-counter64;
      description "Incoming ICMPv6 packets dropped because of current policy.";
    }
    leaf drop-in-by-policy-icmpv6-packets {
      type yang:zero-based-counter64;
      description "Incoming ICMPv6 packets dropped because of current policy.";
    }
    leaf drop-in-by-rfc7596-icmpv4-bytes {
      type yang:zero-based-counter64;
      description
        "Incoming ICMPv4 packets with no destination (RFC 7596 section 8.1).";
    }
    leaf drop-in-by-rfc7596-icmpv4-packets {
      type yang:zero-based-counter64;
      description
        "Incoming ICMPv4 packets with no destination (RFC 7596 section 8.1).";
    }
    leaf drop-ipv4-frag-disabled {
      type yang:zero-based-counter64;
      description
        "If fragmentation is disabled, the only potentially non-zero IPv4
         fragmentation counter is drop-ipv4-frag-disabled. If fragmentation is
         enabled, it will always be zero.";
    }
    leaf drop-ipv4-frag-invalid-reassembly {
      type yang:zero-based-counter64;
      description
        "Two or more IPv4 fragments were received, and reassembly was started,
         but was invalid and dropped. Causes include multiple fragments claiming
         they are the last fragment, overlapping fragment offsets, or the packet
         was being reassembled from too many fragments (the setting is
         max_fragments_per_reassembly_packet, and the default is that no packet
         should be reassembled from more than 40).";
    }
    leaf drop-ipv4-frag-random-evicted {
      type yang:zero-based-counter64;
      description
        "Reassembling an IPv4 packet from fragments was in progress, but the
         configured amount of packets to reassemble at once was exceeded, so one
         was dropped at random. Consider increasing the setting
         max_ipv4_reassembly_packets.";
    }
    leaf drop-ipv6-frag-disabled {
      type yang:zero-based-counter64;
      description
        "If fragmentation is disabled, the only potentially non-zero IPv6
         fragmentation counter is drop-ipv6-frag-disabled. If fragmentation is
         enabled, it will always be zero.";
    }
    leaf drop-ipv6-frag-invalid-reassembly {
      type yang:zero-based-counter64;
      description
        "Two or more IPv6 fragments were received, and reassembly was started,
         but was invalid and dropped. Causes include multiple fragments claiming
         they are the last fragment, overlapping fragment offsets, or the packet
         was being reassembled from too many fragments (the setting is
         max_fragments_per_reassembly_packet, and the default is that no packet
         should be reassembled from more than 40).";
    }
    leaf drop-ipv6-frag-random-evicted {
      type yang:zero-based-counter64;
      description
        "Reassembling an IPv6 packet from fragments was in progress, but the
        configured amount of packets to reassemble at once was exceeded, so one
        was dropped at random. Consider increasing the setting
        max_ipv6_reassembly_packets.";
    }
    leaf drop-misplaced-not-ipv4-bytes {
      type yang:zero-based-counter64;
      description "Non-IPv4 packets incoming on the IPv4 link.";
    }
    leaf drop-misplaced-not-ipv4-packets {
      type yang:zero-based-counter64;
      description "Non-IPv4 packets incoming on the IPv4 link.";
    }
    leaf drop-misplaced-not-ipv6-bytes {
      type yang:zero-based-counter64;
      description "Non-IPv6 packets incoming on IPv6 link.";
    }
    leaf drop-misplaced-not-ipv6-packets {
      type yang:zero-based-counter64;
      description "Non-IPv6 packets incoming on IPv6 link.";
    }
    leaf drop-no-dest-router-ipv4-bytes {
      type yang:zero-based-counter64;
      description
        "No matching destination router in the binding table; incremented
         whether or not the reason was RFC7596.";
    }
    leaf drop-no-dest-router-ipv4-packets {
      type yang:zero-based-counter64;
      description
        "No matching destination router in the binding table; incremented
         whether or not the reason was RFC7596.";
    }
    leaf drop-no-source-router-ipv6-bytes {
      type yang:zero-based-counter64;
      description
        "No matching source router in the binding table; incremented whether
         or not the reason was RFC7596.";
    }
    leaf drop-no-source-router-ipv6-packets {
      type yang:zero-based-counter64;
      description
        "No matching source router in the binding table; incremented whether
         or not the reason was RFC7596.";
    }
    leaf drop-out-by-policy-icmpv4-packets {
      type yang:zero-based-counter64;
      description
        "Internally generated ICMPv4 error packets dropped because of current
         policy.";
    }
    leaf drop-out-by-policy-icmpv6-packets {
      type yang:zero-based-counter64;
      description
        "Internally generated ICMPv6 packets dropped because of current
         policy.";
    }
    leaf drop-over-mtu-but-dont-fragment-ipv4-bytes {
      type yang:zero-based-counter64;
      description
        "IPv4 packets whose size exceeded the MTU, but the DF (Don't Fragment)
         flag was set.";
    }
    leaf drop-over-mtu-but-dont-fragment-ipv4-packets {
      type yang:zero-based-counter64;
      description
        "IPv4 packets whose size exceeded the MTU, but the DF (Don't Fragment)
         flag was set.";
    }
    leaf drop-over-rate-limit-icmpv6-bytes {
      type yang:zero-based-counter64;
      description
        "Packets dropped because the outgoing ICMPv6 rate limit was reached.";
    }
    leaf drop-over-rate-limit-icmpv6-packets {
      type yang:zero-based-counter64;
      description
        "Packets dropped because the outgoing ICMPv6 rate limit was reached.";
    }
    leaf drop-over-time-but-not-hop-limit-icmpv6-bytes {
      type yang:zero-based-counter64;
      description
        "Packet's time limit was exceeded, but the hop limit was not.";
    }
    leaf drop-over-time-but-not-hop-limit-icmpv6-packets {
      type yang:zero-based-counter64;
      description
        "Packet's time limit was exceeded, but the hop limit was not.";
    }
    leaf drop-too-big-type-but-not-code-icmpv6-bytes {
      type yang:zero-based-counter64;
      description
        "Packet's ICMP type was 'Packet too big' but its ICMP code was not an
         acceptable one for this type.";
    }
    leaf drop-too-big-type-but-not-code-icmpv6-packets {
      type yang:zero-based-counter64;
      description
        "Packet's ICMP type was 'Packet too big' but its ICMP code was not an
         acceptable one for this type.";
    }
    leaf drop-ttl-zero-ipv4-bytes {
      type yang:zero-based-counter64;
      description "IPv4 packets dropped because their TTL was zero.";
    }
    leaf drop-ttl-zero-ipv4-packets {
      type yang:zero-based-counter64;
      description "IPv4 packets dropped because their TTL was zero.";
    }
    leaf drop-unknown-protocol-icmpv6-bytes {
      type yang:zero-based-counter64;
      description "Packets with an unknown ICMPv6 protocol.";
    }
    leaf drop-unknown-protocol-icmpv6-packets {
      type yang:zero-based-counter64;
      description "Packets with an unknown ICMPv6 protocol.";
    }
    leaf drop-unknown-protocol-ipv6-bytes {
      type yang:zero-based-counter64;
      description "Packets with an unknown IPv6 protocol.";
    }
    leaf drop-unknown-protocol-ipv6-packets {
      type yang:zero-based-counter64;
      description "Packets with an unknown IPv6 protocol.";
    }
    leaf hairpin-ipv4-bytes {
      type yang:zero-based-counter64;
      description "IPv4 packets going to a known b4 (hairpinned).";
    }
    leaf hairpin-ipv4-packets {
      type yang:zero-based-counter64;
      description "IPv4 packets going to a known b4 (hairpinned).";
    }
    leaf in-ipv4-bytes {
      type yang:zero-based-counter64;
      description "All valid outgoing IPv4 packets.";
    }
    leaf in-ipv4-frag-needs-reassembly {
      type yang:zero-based-counter64;
      description "An IPv4 fragment was received.";
    }
    leaf in-ipv4-frag-reassembled {
      type yang:zero-based-counter64;
      description "A packet was successfully reassembled from IPv4 fragments.";
    }
    leaf in-ipv4-frag-reassembly-unneeded {
      type yang:zero-based-counter64;
      description
        "An IPv4 packet which was not a fragment was received - consequently,
         it did not need to be reassembled. This should be the usual case.";
    }
    leaf in-ipv4-packets {
      type yang:zero-based-counter64;
      description "All valid outgoing IPv4 packets.";
    }
    leaf in-ipv6-bytes {
      type yang:zero-based-counter64;
      description "All valid outgoing IPv4 packets.";
    }
    leaf in-ipv6-frag-needs-reassembly {
      type yang:zero-based-counter64;
      description "An IPv6 fragment was received.";
    }
    leaf in-ipv6-frag-reassembled {
      type yang:zero-based-counter64;
      description "A packet was successfully reassembled from IPv6 fragments.";
    }
    leaf in-ipv6-frag-reassembly-unneeded {
      type yang:zero-based-counter64;
      description
        "An IPv6 packet which was not a fragment was received - consequently, it
         did not need to be reassembled. This should be the usual case.";
    }
    leaf in-ipv6-packets {
      type yang:zero-based-counter64;
      description "All valid outgoing IPv4 packets.";
    }
    leaf ingress-packet-drops {
      type yang:zero-based-counter64;
      description "Packets dropped due to ingress filters.";
    }
    leaf memuse-ipv4-frag-reassembly-buffer {
      type yang:zero-based-counter64;
      description
        "The amount of memory being used by the statically sized data structure
         for reassembling IPv4 fragments. This is directly proportional to the
        setting max_ipv4_reassembly_packets.";
    }
    leaf memuse-ipv6-frag-reassembly-buffer {
      type yang:zero-based-counter64;
      description
        "The amount of memory being used by the statically sized data structure
         for reassembling IPv6 fragments. This is directly proportional to the
         setting max_ipv6_reassembly_packets.";
    }
    leaf out-icmpv4-bytes {
      type yang:zero-based-counter64;
      description "Internally generated ICMPv4 packets.";
    }
    leaf out-icmpv4-packets {
      type yang:zero-based-counter64;
      description "Internally generated ICMPv4 packets.";
    }
    leaf out-icmpv6-bytes {
      type yang:zero-based-counter64;
      description "Internally generted ICMPv6 error packets.";
    }
    leaf out-icmpv6-packets {
      type yang:zero-based-counter64;
      description "Internally generted ICMPv6 error packets.";
    }
    leaf out-ipv4-bytes {
      type yang:zero-based-counter64;
      description "Valid outgoing IPv4 packets.";
    }
    leaf out-ipv4-frag {
      type yang:zero-based-counter64;
      description
        "An outgoing packet exceeded the configured IPv4 MTU, so needed to be
         fragmented. This may happen, but should be unusual.";
    }
    leaf out-ipv4-frag-not {
      type yang:zero-based-counter64;
      description
        "An outgoing packet was small enough to pass through unfragmented - this
         should be the usual case.";
    }
    leaf out-ipv4-packets {
      type yang:zero-based-counter64;
      description "Valid outgoing IPv4 packets.";
    }
    leaf out-ipv6-bytes {
      type yang:zero-based-counter64;
      description "All valid outgoing IPv6 packets.";
    }
    leaf out-ipv6-frag {
      type yang:zero-based-counter64;
      description
        "An outgoing packet exceeded the configured IPv6 MTU, so needed to be
        fragmented. This may happen, but should be unusual.";
    }
    leaf out-ipv6-frag-not {
      type yang:zero-based-counter64;
      description
        "An outgoing packet was small enough to pass through unfragmented - this
         should be the usual case.";
    }
    leaf out-ipv6-packets {
      type yang:zero-based-counter64;
      description "All valid outgoing IPv6 packets.";
    }
  }
}
